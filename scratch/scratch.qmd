---
editor: 
  markdown: 
    wrap: 72
---

# some other points

-   The idea of managing complexity and flipping that so it is a design tool
    - that is: functions are tools to manage complexity
    - So to write a good function you should look at some code and think what is the complexity I want to manage

## Three parts to the talk

> \[W\]e want to establish the idea that a computer language is not just
> a way of getting a computer to perform operations but rather that it
> is a novel formal medium for **expressing ideas about methodology**.
> Thus, programs must be **written for people to read**, and only
> incidentally for machines to execute.
>
> — [Structure and Interpretation of Computer
> Programs](https://mitpress.mit.edu/9780262510875/). Abelson, Sussman,
> and Sussman, 1984.

1.  Motivating functions in the classic sense (only update once, remove
    copy/paste errors, name to help understand).
    1.  And this is *good* motivation to use functions. It's what got me
        there.
2.  A demonstration of using functions
    1.  This part of the talk will be a fully live coded example of
        doing a data analysis.
    2.  In this part of the talk I want to help demonstrate that
        functions are tools that help you manage complexity in a data
        analysis.
    3.  I want to steer people away from this idea that "functions are
        an occasional thing", and instead convince you they should be
        part of your regular toolset.
    4.  Perhaps just a demonstration of all the most recent functions
        that I've written?
        1.  The visdat helpers
        2.  the geotargets helpers?
3.  Functions should become staples
    1.  These aren't the "sometimes" treat of a delicious birthday cake.
        Functions should be a staple part of your diet, like water,
        coffee, tea, carbohydrates, protein. They should be the main
        macro of your input/output
4.  Writing functions begets more functions
    1.  You start writing a function like add_predictions(), and then
        you go, well, may there should be add_residuals(), and then
        maybe there should be add_se()

1.  General statement around why functions are important
2.  My goals of this talk are that I want you to walk away knowing:
    -   How to name a function
    -   How to write a function
    -   What a function should produce
    -   How to identify a good function
    -   How to identify a bad function
3.  Giving people the tools to write functions, but also to explore and
    verify:
    -   browser
    -   debug/debugonce
        -   argument:
            -   I like seeing all the code - the functions are
                obfuscating the code, how can I trust it?
            -   This is why you need browser and friends.
            -   Demonstrate the ability to use debug, to Cmd + click in
                RStudio / VS Code.
            -   How do you not got on a really deep journey? Cheat:
                `options(error = recover)`
        -   
4.  Two parts:
    1.  Good functions are easy to reason with. I want to convince you
        that DRY isn’t the best reason/motivation to explain or teach
        functions. The reason is that good functions should be easy to
        reason with. 1.5: Examples of creating a data analysis and
        moving from a script into
    2.  How to teach functions.

# unsorted

-   The idea of "prefactoring" - As Jenny Bryan said [in her
    keynote](https://www.youtube.com/watch?v=7oyiPBjLAWY&t=3s):\>
    "There's a term based on refactoring called "pre-factoring", which
    is: 'if you do enough of this refactoring, it also starts to
    influence the way you write this code the first time.'
    
- Functions are tools for managing complexity. So what happens when you have all of these nicely written functions that operate in a complex way? This is when we need functions to help manage functions: browser() and debugonce().
------------------------------------------------------------------------

# Other ideas

Do I want to get into for loops, and why I think they are fine, but you
might want to consider something else?

Do I want to consider discussing `return` and using `tibble::lst`

Workshop naming functions - using verbs - prefix functions for
discoverability - stick to a common style - I prefer snake_case, but you
can do whatever - just be consistent and don't mix the two in your code,
or hybridise them like: `UpperCamel_snake_case_Mix` - it will almost
certainly be harder to remember - argument names: try giving them more
imaginative names other than `x` and `y`.

Some condensed advice from design.tidyverse.com

-   place `...` early to require users to name arguments
-   prefer arguments that take in a character vector over multiple
    TRUE/FALSE arguments
